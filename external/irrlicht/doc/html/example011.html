<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Irrlicht 3D Engine: Tutorial 11: Per-Pixel Lighting</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="irrlichtlogo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht 3D Engine
   
   </div>
   
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('example011.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 11: Per-Pixel Lighting </div>  </div>
</div>
<div class="contents">
<div class="textblock"><div class="image">
<img src="011shot.jpg" alt="011shot.jpg"/>
</div>
 <p>This tutorial shows how to use one of the built in more complex materials in irrlicht: Per pixel lighted surfaces using normal maps and parallax mapping. It will also show how to use fog and moving particle systems. And don't panic: You do not need any experience with shaders to use these materials in Irrlicht.</p>
<p>At first, we need to include all headers and do the stuff we always do, like in nearly all other tutorials. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="irrlicht_8h.html" title="Main header file of the irrlicht, the only file needed to include.">irrlicht.h</a>&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="driver_choice_8h.html">driverChoice.h</a>&quot;</span>

<span class="keyword">using namespace </span>irr;

<span class="preprocessor">#ifdef _MSC_VER</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span>
<span class="preprocessor">#endif</span>
</pre></div><p>For this example, we need an event receiver, to make it possible for the user to switch between the three available material types. In addition, the event receiver will create some small GUI window which displays what material is currently being used. There is nothing special done in this class, so maybe you want to skip reading it. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyEventReceiver : <span class="keyword">public</span> IEventReceiver
{
<span class="keyword">public</span>:

    MyEventReceiver(scene::ISceneNode* room,scene::ISceneNode* earth,
        gui::IGUIEnvironment* env, video::IVideoDriver* driver)
    {
        <span class="comment">// store pointer to room so we can change its drawing mode</span>
        Room = room;
        Earth = earth;
        Driver = driver;

        <span class="comment">// set a nicer font</span>
        gui::IGUISkin* skin = env-&gt;getSkin();
        gui::IGUIFont* font = env-&gt;getFont(<span class="stringliteral">&quot;../../media/fonthaettenschweiler.bmp&quot;</span>);
        <span class="keywordflow">if</span> (font)
            skin-&gt;setFont(font);

        <span class="comment">// add window and listbox</span>
        gui::IGUIWindow* window = env-&gt;addWindow(
            core::rect&lt;s32&gt;(460,375,630,470), <span class="keyword">false</span>, L<span class="stringliteral">&quot;Use &#39;E&#39; + &#39;R&#39; to change&quot;</span>);

        ListBox = env-&gt;addListBox(
            core::rect&lt;s32&gt;(2,22,165,88), window);

        ListBox-&gt;addItem(L<span class="stringliteral">&quot;Diffuse&quot;</span>);
        ListBox-&gt;addItem(L<span class="stringliteral">&quot;Bump mapping&quot;</span>);
        ListBox-&gt;addItem(L<span class="stringliteral">&quot;Parallax mapping&quot;</span>);
        ListBox-&gt;setSelected(1);

        <span class="comment">// create problem text</span>
        ProblemText = env-&gt;addStaticText(
            L<span class="stringliteral">&quot;Your hardware or this renderer is not able to use the &quot;</span>\
            L<span class="stringliteral">&quot;needed shaders for this material. Using fall back materials.&quot;</span>,
            core::rect&lt;s32&gt;(150,20,470,80));

        ProblemText-&gt;setOverrideColor(video::SColor(100,255,255,255));

        <span class="comment">// set start material (prefer parallax mapping if available)</span>
        video::IMaterialRenderer* renderer =
            Driver-&gt;getMaterialRenderer(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a833aaad409476c3c4baf59e2d1096f4a" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping.">video::EMT_PARALLAX_MAP_SOLID</a>);
        <span class="keywordflow">if</span> (renderer &amp;&amp; renderer-&gt;getRenderCapability() == 0)
            ListBox-&gt;setSelected(2);

        <span class="comment">// set the material which is selected in the listbox</span>
        setMaterial();
    }

    <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent&amp; event)
    {
        <span class="comment">// check if user presses the key &#39;E&#39; or &#39;R&#39;</span>
        <span class="keywordflow">if</span> (event.EventType == <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0ca6f90390f3147a1693e5e2e3422d6ca09" title="A key input event.">irr::EET_KEY_INPUT_EVENT</a> &amp;&amp;
            !event.KeyInput.PressedDown &amp;&amp; Room &amp;&amp; ListBox)
        {
            <span class="comment">// change selected item in listbox</span>

            <span class="keywordtype">int</span> sel = ListBox-&gt;getSelected();
            <span class="keywordflow">if</span> (event.KeyInput.Key == <a class="code" href="namespaceirr.html#a54da2a0e231901735e3da1b0edf72eb3a69dba8cbd4fc6825c6ac18ebe13c6eba">irr::KEY_KEY_R</a>)
                ++sel;
            <span class="keywordflow">else</span>
            <span class="keywordflow">if</span> (event.KeyInput.Key == <a class="code" href="namespaceirr.html#a54da2a0e231901735e3da1b0edf72eb3af378ce3d6f5cbd09a1ae4ec8f44a0079">irr::KEY_KEY_E</a>)
                --sel;
            <span class="keywordflow">else</span>
                <span class="keywordflow">return</span> <span class="keyword">false</span>;

            <span class="keywordflow">if</span> (sel &gt; 2) sel = 0;
            <span class="keywordflow">if</span> (sel &lt; 0) sel = 2;
            ListBox-&gt;setSelected(sel);

            <span class="comment">// set the material which is selected in the listbox</span>
            setMaterial();
        }

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

<span class="keyword">private</span>:

    <span class="comment">// sets the material of the room mesh the the one set in the</span>
    <span class="comment">// list box.</span>
    <span class="keywordtype">void</span> setMaterial()
    {
        <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a> type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a9bc471b9c18c9e2d20496004d2a2e803" title="Standard solid material.">video::EMT_SOLID</a>;

        <span class="comment">// change material setting</span>
        <span class="keywordflow">switch</span>(ListBox-&gt;getSelected())
        {
        <span class="keywordflow">case</span> 0: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a9bc471b9c18c9e2d20496004d2a2e803" title="Standard solid material.">video::EMT_SOLID</a>;
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a89220ece17ea7d54a530de9756734c70" title="A solid normal map renderer.">video::EMT_NORMAL_MAP_SOLID</a>;
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 2: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a833aaad409476c3c4baf59e2d1096f4a" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping.">video::EMT_PARALLAX_MAP_SOLID</a>;
            <span class="keywordflow">break</span>;
        }

        Room-&gt;setMaterialType(type);

        <span class="comment">// change material setting</span>
        <span class="keywordflow">switch</span>(ListBox-&gt;getSelected())
        {
        <span class="keywordflow">case</span> 0: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a26529b1cf18ec4d8073809f6bd15ebbb" title="Makes the material transparent based on the vertex alpha value.">video::EMT_TRANSPARENT_VERTEX_ALPHA</a>;
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a0d6f6973795d52d137955699537565db" title="A transparent (based on the vertex alpha value) normal map renderer.">video::EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA</a>;
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 2: type = <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a4c3e6b604a6d0fc5dffec661f470c11a" title="A material like EMT_PARALLAX_MAP_SOLID, but transparent.">video::EMT_PARALLAX_MAP_TRANSPARENT_VERTEX_ALPHA</a>;
            <span class="keywordflow">break</span>;
        }

        Earth-&gt;setMaterialType(type);
</pre></div><p>We need to add a warning if the materials will not be able to be displayed 100% correctly. This is no problem, they will be rendered using fall back materials, but at least the user should know that it would look better on better hardware. We simply check if the material renderer is able to draw at full quality on the current hardware. The IMaterialRenderer::getRenderCapability() returns 0 if this is the case. </p>
<div class="fragment"><pre class="fragment">        video::IMaterialRenderer* renderer = Driver-&gt;getMaterialRenderer(type);

        <span class="comment">// display some problem text when problem</span>
        <span class="keywordflow">if</span> (!renderer || renderer-&gt;getRenderCapability() != 0)
            ProblemText-&gt;setVisible(<span class="keyword">true</span>);
        <span class="keywordflow">else</span>
            ProblemText-&gt;setVisible(<span class="keyword">false</span>);
    }

<span class="keyword">private</span>:

    gui::IGUIStaticText* ProblemText;
    gui::IGUIListBox* ListBox;

    scene::ISceneNode* Room;
    scene::ISceneNode* Earth;
    video::IVideoDriver* Driver;
};
</pre></div><p>Now for the real fun. We create an Irrlicht Device and start to setup the scene. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main()
{
    <span class="comment">// ask user for driver</span>
    <a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0" title="An enum for all types of drivers the Irrlicht Engine supports.">video::E_DRIVER_TYPE</a> driverType=driverChoiceConsole();
    <span class="keywordflow">if</span> (driverType==<a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0ae685cada50f8c100403134d932d0414c" title="No driver, just for counting the elements.">video::EDT_COUNT</a>)
        <span class="keywordflow">return</span> 1;

    <span class="comment">// create device</span>

    IrrlichtDevice* device = <a class="code" href="namespaceirr.html#abaf4d8719cc26b0d30813abf85e47c76" title="Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.">createDevice</a>(driverType,
            core::dimension2d&lt;u32&gt;(640, 480));

    <span class="keywordflow">if</span> (device == 0)
        <span class="keywordflow">return</span> 1; <span class="comment">// could not create selected driver.</span>
</pre></div><p>Before we start with the interesting stuff, we do some simple things: Store pointers to the most important parts of the engine (video driver, scene manager, gui environment) to safe us from typing too much, add an irrlicht engine logo to the window and a user controlled first person shooter style camera. Also, we let the engine know that it should store all textures in 32 bit. This necessary because for parallax mapping, we need 32 bit textures. </p>
<div class="fragment"><pre class="fragment">    video::IVideoDriver* driver = device-&gt;getVideoDriver();
    scene::ISceneManager* smgr = device-&gt;getSceneManager();
    gui::IGUIEnvironment* env = device-&gt;getGUIEnvironment();

    driver-&gt;setTextureCreationFlag(<a class="code" href="namespaceirr_1_1video.html#acaf6f7414534f7d62bff18c5bf11876fa20881e307a778c4a4fbb5327a60a93bb">video::ETCF_ALWAYS_32_BIT</a>, <span class="keyword">true</span>);

    <span class="comment">// add irrlicht logo</span>
    env-&gt;addImage(driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/irrlichtlogo3.png&quot;</span>),
        core::position2d&lt;s32&gt;(10,10));

    <span class="comment">// add camera</span>
    scene::ICameraSceneNode* camera = smgr-&gt;addCameraSceneNodeFPS();
    camera-&gt;setPosition(<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(-200,200,-200));

    <span class="comment">// disable mouse cursor</span>
    device-&gt;getCursorControl()-&gt;setVisible(<span class="keyword">false</span>);
</pre></div><p>Because we want the whole scene to look a little bit scarier, we add some fog to it. This is done by a call to IVideoDriver::setFog(). There you can set various fog settings. In this example, we use pixel fog, because it will work well with the materials we'll use in this example. Please note that you will have to set the material flag EMF_FOG_ENABLE to 'true' in every scene node which should be affected by this fog. </p>
<div class="fragment"><pre class="fragment">    driver-&gt;setFog(video::SColor(0,138,125,81), <a class="code" href="namespaceirr_1_1video.html#adf41b1a85e067f5988ba1eb8bb50f44ea998abcfd4824aaf15a95678bb444ef65">video::EFT_FOG_LINEAR</a>, 250, 1000, .003f, <span class="keyword">true</span>, <span class="keyword">false</span>);
</pre></div><p>To be able to display something interesting, we load a mesh from a .3ds file which is a room I modeled with anim8or. It is the same room as from the specialFX example. Maybe you remember from that tutorial, I am no good modeler at all and so I totally messed up the texture mapping in this model, but we can simply repair it with the IMeshManipulator::makePlanarTextureMapping() method. </p>
<div class="fragment"><pre class="fragment">    scene::IAnimatedMesh* roomMesh = smgr-&gt;getMesh(<span class="stringliteral">&quot;../../media/room.3ds&quot;</span>);
    scene::ISceneNode* room = 0;
    scene::ISceneNode* earth = 0;

    <span class="keywordflow">if</span> (roomMesh)
    {
        <span class="comment">// The Room mesh doesn&#39;t have proper Texture Mapping on the</span>
        <span class="comment">// floor, so we can recreate them on runtime</span>
        smgr-&gt;getMeshManipulator()-&gt;makePlanarTextureMapping(
                roomMesh-&gt;getMesh(0), 0.003f);
</pre></div><p>Now for the first exciting thing: If we successfully loaded the mesh we need to apply textures to it. Because we want this room to be displayed with a very cool material, we have to do a little bit more than just set the textures. Instead of only loading a color map as usual, we also load a height map which is simply a grayscale texture. From this height map, we create a normal map which we will set as second texture of the room. If you already have a normal map, you could directly set it, but I simply didn't find a nice normal map for this texture. The normal map texture is being generated by the makeNormalMapTexture method of the VideoDriver. The second parameter specifies the height of the heightmap. If you set it to a bigger value, the map will look more rocky. </p>
<div class="fragment"><pre class="fragment">        video::ITexture* normalMap =
            driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/rockwall_height.bmp&quot;</span>);

        <span class="keywordflow">if</span> (normalMap)
            driver-&gt;makeNormalMapTexture(normalMap, 9.0f);
</pre></div><p>The Normal Map and the displacement map/height map in the alpha channel video::ITexture* normalMap = driver-&gt;getTexture("../../media/rockwall_NRM.tga"); </p>
<div class="fragment"><pre class="fragment"></pre></div><p>But just setting color and normal map is not everything. The material we want to use needs some additional informations per vertex like tangents and binormals. Because we are too lazy to calculate that information now, we let Irrlicht do this for us. That's why we call IMeshManipulator::createMeshWithTangents(). It creates a mesh copy with tangents and binormals from another mesh. After we've done that, we simply create a standard mesh scene node with this mesh copy, set color and normal map and adjust some other material settings. Note that we set EMF_FOG_ENABLE to true to enable fog in the room. </p>
<div class="fragment"><pre class="fragment">        scene::IMesh* tangentMesh = smgr-&gt;getMeshManipulator()-&gt;
                createMeshWithTangents(roomMesh-&gt;getMesh(0));

        room = smgr-&gt;addMeshSceneNode(tangentMesh);
        room-&gt;setMaterialTexture(0,
                driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/rockwall.jpg&quot;</span>));
        room-&gt;setMaterialTexture(1, normalMap);

        <span class="comment">// Stones don&#39;t glitter..</span>
        room-&gt;getMaterial(0).SpecularColor.set(0,0,0,0);
        room-&gt;getMaterial(0).Shininess = 0.f;

        room-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3a5b898e76a9f5e5cfb9c27bee1fbc38be" title="Is fog enabled? Default: false.">video::EMF_FOG_ENABLE</a>, <span class="keyword">true</span>);
        room-&gt;setMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a833aaad409476c3c4baf59e2d1096f4a" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping.">video::EMT_PARALLAX_MAP_SOLID</a>);
        <span class="comment">// adjust height for parallax effect</span>
        room-&gt;getMaterial(0).MaterialTypeParam = 1.f / 64.f;

        <span class="comment">// drop mesh because we created it with a create.. call.</span>
        tangentMesh-&gt;drop();
    }
</pre></div><p>After we've created a room shaded by per pixel lighting, we add a sphere into it with the same material, but we'll make it transparent. In addition, because the sphere looks somehow like a familiar planet, we make it rotate. The procedure is similar as before. The difference is that we are loading the mesh from an .x file which already contains a color map so we do not need to load it manually. But the sphere is a little bit too small for our needs, so we scale it by the factor 50. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// add earth sphere</span>

    scene::IAnimatedMesh* earthMesh = smgr-&gt;getMesh(<span class="stringliteral">&quot;../../media/earth.x&quot;</span>);
    <span class="keywordflow">if</span> (earthMesh)
    {
        <span class="comment">//perform various task with the mesh manipulator</span>
        scene::IMeshManipulator *manipulator = smgr-&gt;getMeshManipulator();

        <span class="comment">// create mesh copy with tangent informations from original earth.x mesh</span>
        scene::IMesh* tangentSphereMesh =
            manipulator-&gt;createMeshWithTangents(earthMesh-&gt;getMesh(0));

        <span class="comment">// set the alpha value of all vertices to 200</span>
        manipulator-&gt;setVertexColorAlpha(tangentSphereMesh, 200);

        <span class="comment">// scale the mesh by factor 50</span>
        <a class="code" href="namespaceirr_1_1core.html#a73fa92e638c5ca97efd72da307cc9b65" title="Typedef for f32 matrix.">core::matrix4</a> m;
        m.setScale ( <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(50,50,50) );
        manipulator-&gt;transform( tangentSphereMesh, m );

        earth = smgr-&gt;addMeshSceneNode(tangentSphereMesh);

        earth-&gt;setPosition(<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(-70,130,45));

        <span class="comment">// load heightmap, create normal map from it and set it</span>
        video::ITexture* earthNormalMap = driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/earthbump.jpg&quot;</span>);
        <span class="keywordflow">if</span> (earthNormalMap)
        {
            driver-&gt;makeNormalMapTexture(earthNormalMap, 20.0f);
            earth-&gt;setMaterialTexture(1, earthNormalMap);
            earth-&gt;setMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a0d6f6973795d52d137955699537565db" title="A transparent (based on the vertex alpha value) normal map renderer.">video::EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA</a>);
        }

        <span class="comment">// adjust material settings</span>
        earth-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3a5b898e76a9f5e5cfb9c27bee1fbc38be" title="Is fog enabled? Default: false.">video::EMF_FOG_ENABLE</a>, <span class="keyword">true</span>);

        <span class="comment">// add rotation animator</span>
        scene::ISceneNodeAnimator* anim =
            smgr-&gt;createRotationAnimator(<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0,0.1f,0));
        earth-&gt;addAnimator(anim);
        anim-&gt;drop();

        <span class="comment">// drop mesh because we created it with a create.. call.</span>
        tangentSphereMesh-&gt;drop();
    }
</pre></div><p>Per pixel lighted materials only look cool when there are moving lights. So we add some. And because moving lights alone are so boring, we add billboards to them, and a whole particle system to one of them. We start with the first light which is red and has only the billboard attached. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// add light 1 (more green)</span>
    scene::ILightSceneNode* light1 =
        smgr-&gt;addLightSceneNode(0, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0,0,0),
        video::SColorf(0.5f, 1.0f, 0.5f, 0.0f), 800.0f);

    light1-&gt;setDebugDataVisible ( <a class="code" href="namespaceirr_1_1scene.html#a52b664c4c988113735042b168fc32dbea19e56bb3d3b18134fa63e0529629b427" title="Show Bounding Boxes of SceneNode.">scene::EDS_BBOX</a> );


    <span class="comment">// add fly circle animator to light 1</span>
    scene::ISceneNodeAnimator* anim =
        smgr-&gt;createFlyCircleAnimator (<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(50,300,0),190.0f, -0.003f);
    light1-&gt;addAnimator(anim);
    anim-&gt;drop();

    <span class="comment">// attach billboard to the light</span>
    scene::IBillboardSceneNode* bill =
        smgr-&gt;addBillboardSceneNode(light1, core::dimension2d&lt;f32&gt;(60, 60));

    bill-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3acea597a2692b8415486a464a7f954d34" title="Will this material be lighted? Default: true.">video::EMF_LIGHTING</a>, <span class="keyword">false</span>);
    bill-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3a4bc03b7b9dd19e577bf909313ea62510" title="May be written to the zbuffer or is it readonly. Default: true.">video::EMF_ZWRITE_ENABLE</a>, <span class="keyword">false</span>);
    bill-&gt;setMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a1b5a814c4466aca2943ff056003a50d1" title="A transparent material.">video::EMT_TRANSPARENT_ADD_COLOR</a>);
    bill-&gt;setMaterialTexture(0, driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/particlegreen.jpg&quot;</span>));
</pre></div><p>Now the same again, with the second light. The difference is that we add a particle system to it too. And because the light moves, the particles of the particlesystem will follow. If you want to know more about how particle systems are created in Irrlicht, take a look at the specialFx example. Maybe you will have noticed that we only add 2 lights, this has a simple reason: The low end version of this material was written in ps1.1 and vs1.1, which doesn't allow more lights. You could add a third light to the scene, but it won't be used to shade the walls. But of course, this will change in future versions of Irrlicht where higher versions of pixel/vertex shaders will be implemented too. </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// add light 2 (red)</span>
    scene::ISceneNode* light2 =
        smgr-&gt;addLightSceneNode(0, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0,0,0),
        video::SColorf(1.0f, 0.2f, 0.2f, 0.0f), 800.0f);

    <span class="comment">// add fly circle animator to light 2</span>
    anim = smgr-&gt;createFlyCircleAnimator(<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0,150,0), 200.0f,
            0.001f, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0.2f, 0.9f, 0.f));
    light2-&gt;addAnimator(anim);
    anim-&gt;drop();

    <span class="comment">// attach billboard to light</span>
    bill = smgr-&gt;addBillboardSceneNode(light2, core::dimension2d&lt;f32&gt;(120, 120));
    bill-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3acea597a2692b8415486a464a7f954d34" title="Will this material be lighted? Default: true.">video::EMF_LIGHTING</a>, <span class="keyword">false</span>);
    bill-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3a4bc03b7b9dd19e577bf909313ea62510" title="May be written to the zbuffer or is it readonly. Default: true.">video::EMF_ZWRITE_ENABLE</a>, <span class="keyword">false</span>);
    bill-&gt;setMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a1b5a814c4466aca2943ff056003a50d1" title="A transparent material.">video::EMT_TRANSPARENT_ADD_COLOR</a>);
    bill-&gt;setMaterialTexture(0, driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/particlered.bmp&quot;</span>));

    <span class="comment">// add particle system</span>
    scene::IParticleSystemSceneNode* ps =
        smgr-&gt;addParticleSystemSceneNode(<span class="keyword">false</span>, light2);

    <span class="comment">// create and set emitter</span>
    scene::IParticleEmitter* em = ps-&gt;createBoxEmitter(
        core::aabbox3d&lt;f32&gt;(-3,0,-3,3,1,3),
        <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0.0f,0.03f,0.0f),
        80,100,
        video::SColor(10,255,255,255), video::SColor(10,255,255,255),
        400,1100);
    em-&gt;setMinStartSize(core::dimension2d&lt;f32&gt;(30.0f, 40.0f));
    em-&gt;setMaxStartSize(core::dimension2d&lt;f32&gt;(30.0f, 40.0f));

    ps-&gt;setEmitter(em);
    em-&gt;drop();

    <span class="comment">// create and set affector</span>
    scene::IParticleAffector* paf = ps-&gt;createFadeOutParticleAffector();
    ps-&gt;addAffector(paf);
    paf-&gt;drop();

    <span class="comment">// adjust some material settings</span>
    ps-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3acea597a2692b8415486a464a7f954d34" title="Will this material be lighted? Default: true.">video::EMF_LIGHTING</a>, <span class="keyword">false</span>);
    ps-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3a4bc03b7b9dd19e577bf909313ea62510" title="May be written to the zbuffer or is it readonly. Default: true.">video::EMF_ZWRITE_ENABLE</a>, <span class="keyword">false</span>);
    ps-&gt;setMaterialTexture(0, driver-&gt;getTexture(<span class="stringliteral">&quot;../../media/fireball.bmp&quot;</span>));
    ps-&gt;setMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a1b5a814c4466aca2943ff056003a50d1" title="A transparent material.">video::EMT_TRANSPARENT_ADD_COLOR</a>);

    MyEventReceiver receiver(room, earth, env, driver);
    device-&gt;setEventReceiver(&amp;receiver);
</pre></div><p>Finally, draw everything. That's it. </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> lastFPS = -1;

    <span class="keywordflow">while</span>(device-&gt;run())
    <span class="keywordflow">if</span> (device-&gt;isWindowActive())
    {
        driver-&gt;beginScene(<span class="keyword">true</span>, <span class="keyword">true</span>, 0);

        smgr-&gt;drawAll();
        env-&gt;drawAll();

        driver-&gt;endScene();

        <span class="keywordtype">int</span> fps = driver-&gt;getFPS();

        <span class="keywordflow">if</span> (lastFPS != fps)
        {
            <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a> str = L<span class="stringliteral">&quot;Per pixel lighting example - Irrlicht Engine [&quot;</span>;
            str += driver-&gt;getName();
            str += <span class="stringliteral">&quot;] FPS:&quot;</span>;
            str += fps;

            device-&gt;setWindowCaption(str.c_str());
            lastFPS = fps;
        }
    }

    device-&gt;drop();

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">
<a href="http://irrlicht.sourceforge.net" target="_blank">Irrlicht 
Engine</a> Documentation &copy; 2003-2012 by Nikolaus Gebhardt. Generated on Tue Nov 6 2012 11:06:01 for Irrlicht 3D Engine by
<a href="http://www.doxygen.org/index.html" target="_blank">Doxygen</a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
