<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Irrlicht 3D Engine: Tutorial 22: Material Viewer</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="irrlichtlogo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht 3D Engine
   
   </div>
   
  </td>
  
  
  
   
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('example022.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 22: Material Viewer </div>  </div>
</div>
<div class="contents">
<div class="textblock"><div class="image">
<img src="022shot.jpg" alt="022shot.jpg"/>
</div>
 <p>This example can be used to play around with material settings and watch the results. Only the default non-shader materials are used in here.</p>
<p>You have two nodes to make it easier to see which difference your settings will make. Additionally you have one lightscenenode and you can set the global ambient values. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="irrlicht_8h.html" title="Main header file of the irrlicht, the only file needed to include.">irrlicht.h</a>&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="driver_choice_8h.html">driverChoice.h</a>&quot;</span>

<span class="keyword">using namespace </span>irr;

<span class="preprocessor">#ifdef _MSC_VER</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span>
<span class="preprocessor">#endif</span>
</pre></div><p>Variables within the empty namespace are globals which are restricted to this file. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace</span>
{
    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* <span class="keyword">const</span> DriverTypeNames[] =
    {
        L<span class="stringliteral">&quot;NULL&quot;</span>,
        L<span class="stringliteral">&quot;SOFTWARE&quot;</span>,
        L<span class="stringliteral">&quot;BURNINGSVIDEO&quot;</span>,
        L<span class="stringliteral">&quot;DIRECT3D8&quot;</span>,
        L<span class="stringliteral">&quot;DIRECT3D9&quot;</span>,
        L<span class="stringliteral">&quot;OPENGL&quot;</span>,
        0,
    };

    <span class="comment">// For the gui id&#39;s</span>
    <span class="keyword">enum</span> EGUI_IDS
    {
        GUI_ID_OPEN_TEXTURE = 1,
        GUI_ID_QUIT,
        GUI_ID_MAX
    };

    <span class="comment">// Name used in texture selection to clear the textures on the node</span>
    <span class="keyword">const</span> <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a> CLEAR_TEXTURE = L<span class="stringliteral">&quot;CLEAR texture&quot;</span>;

    <span class="comment">// some useful color constants</span>
    <span class="keyword">const</span> video::SColor SCOL_BLACK     = video::SColor(255, 0,   0,   0);
    <span class="keyword">const</span> video::SColor SCOL_BLUE      = video::SColor(255, 0,   0,  255);
    <span class="keyword">const</span> video::SColor SCOL_CYAN      = video::SColor(255, 0,  255, 255);
    <span class="keyword">const</span> video::SColor SCOL_GRAY      = video::SColor(255, 128,128, 128);
    <span class="keyword">const</span> video::SColor SCOL_GREEN     = video::SColor(255, 0,  255,  0);
    <span class="keyword">const</span> video::SColor SCOL_MAGENTA   = video::SColor(255, 255, 0,  255);
    <span class="keyword">const</span> video::SColor SCOL_RED       = video::SColor(255, 255, 0,   0);
    <span class="keyword">const</span> video::SColor SCOL_YELLOW    = video::SColor(255, 255, 255, 0);
    <span class="keyword">const</span> video::SColor SCOL_WHITE     = video::SColor(255, 255, 255, 255);
};  <span class="comment">// namespace</span>
</pre></div><p>Returns a new unique number on each call. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> makeUniqueId()
{
    <span class="keyword">static</span> <span class="keywordtype">int</span> unique = GUI_ID_MAX;
    ++unique;
    <span class="keywordflow">return</span> unique;
}
</pre></div><p>Find out which vertex-type is needed for the given material type. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac" title="Enumeration for all vertex types there are.">video::E_VERTEX_TYPE</a> getVertexTypeForMaterialType(<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a> materialType)
{
    <span class="keyword">using namespace </span>video;

    <span class="keywordflow">switch</span> ( materialType )
    {
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a9bc471b9c18c9e2d20496004d2a2e803" title="Standard solid material.">EMT_SOLID</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a3246cbdb780b42b819eb8a24c2ef40d9" title="Solid material with 2 texture layers.">EMT_SOLID_2_LAYER</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a5dc90a3b4a8d82f10503ddf834a3143f" title="Material type with standard lightmap technique.">EMT_LIGHTMAP</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a7aa628bfc8b6ac56c30e93549b799855" title="Material type with lightmap technique like EMT_LIGHTMAP.">EMT_LIGHTMAP_ADD</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1abd740658d7ca152bab745c63107d7edb" title="Material type with standard lightmap technique.">EMT_LIGHTMAP_M2</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1ad61a64f074256bb1cc1b6c130e18ebdc" title="Material type with standard lightmap technique.">EMT_LIGHTMAP_M4</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1add532294454c4842964c79a14ac4af34" title="Like EMT_LIGHTMAP, but also supports dynamic lighting.">EMT_LIGHTMAP_LIGHTING</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a9cd386cb5151eabccbdded029529dec0" title="Like EMT_LIGHTMAP_M2, but also supports dynamic lighting.">EMT_LIGHTMAP_LIGHTING_M2</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a6b7a3c28cfc214c63df8674565e28f17" title="Like EMT_LIGHTMAP_4, but also supports dynamic lighting.">EMT_LIGHTMAP_LIGHTING_M4</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca7b5127a706ee33eb4385d702da007016" title="Vertex with two texture coordinates, video::S3DVertex2TCoords.">EVT_2TCOORDS</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a065af4f8daeb15f81bfe0417a3f231b1" title="Detail mapped material.">EMT_DETAIL_MAP</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca7b5127a706ee33eb4385d702da007016" title="Vertex with two texture coordinates, video::S3DVertex2TCoords.">EVT_2TCOORDS</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a42a8b6f5c933864ca104b3d46692c43b" title="Look like a reflection of the environment around it.">EMT_SPHERE_MAP</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1ad8574343353ed8ade6e78bc04d64b6ae" title="A reflecting material with an optional non reflecting texture layer.">EMT_REFLECTION_2_LAYER</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca7b5127a706ee33eb4385d702da007016" title="Vertex with two texture coordinates, video::S3DVertex2TCoords.">EVT_2TCOORDS</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a1b5a814c4466aca2943ff056003a50d1" title="A transparent material.">EMT_TRANSPARENT_ADD_COLOR</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1ac08aa3715ad41281472202107a81f736" title="Makes the material transparent based on the texture alpha channel.">EMT_TRANSPARENT_ALPHA_CHANNEL</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a167b3eb9c4c09ee1f145d914f4ddb619" title="Makes the material transparent based on the texture alpha channel.">EMT_TRANSPARENT_ALPHA_CHANNEL_REF</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a26529b1cf18ec4d8073809f6bd15ebbb" title="Makes the material transparent based on the vertex alpha value.">EMT_TRANSPARENT_VERTEX_ALPHA</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a8b074c837c82178daa178a3a7321a32d" title="A transparent reflecting material with an optional additional non reflecting texture layer...">EMT_TRANSPARENT_REFLECTION_2_LAYER</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca7b5127a706ee33eb4385d702da007016" title="Vertex with two texture coordinates, video::S3DVertex2TCoords.">EVT_2TCOORDS</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a89220ece17ea7d54a530de9756734c70" title="A solid normal map renderer.">EMT_NORMAL_MAP_SOLID</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a12323a7408cc28c4e57c4ae52758086c" title="A transparent normal map renderer.">EMT_NORMAL_MAP_TRANSPARENT_ADD_COLOR</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a0d6f6973795d52d137955699537565db" title="A transparent (based on the vertex alpha value) normal map renderer.">EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a833aaad409476c3c4baf59e2d1096f4a" title="Just like EMT_NORMAL_MAP_SOLID, but uses parallax mapping.">EMT_PARALLAX_MAP_SOLID</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a84787f1dfcbdc1578ecd84f6de4a22a1" title="A material like EMT_PARALLAX_MAP_SOLID, but transparent.">EMT_PARALLAX_MAP_TRANSPARENT_ADD_COLOR</a>:
        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a4c3e6b604a6d0fc5dffec661f470c11a" title="A material like EMT_PARALLAX_MAP_SOLID, but transparent.">EMT_PARALLAX_MAP_TRANSPARENT_VERTEX_ALPHA</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca8c50b5b2c88f08709d640fecc83dfb9b" title="Vertex with a tangent and binormal vector, video::S3DVertexTangents.">EVT_TANGENTS</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a09498eaf291e1f7abdc04db808cc15d9" title="BlendFunc = source * sourceFactor + dest * destFactor ( E_BLEND_FUNC )">EMT_ONETEXTURE_BLEND</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;

        <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a85962cdf5aab2ddd245cada9b1859e30" title="This value is not used. It only forces this enumeration to compile to 32 bit.">EMT_FORCE_32BIT</a>:
            <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;
    }
    <span class="keywordflow">return</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">EVT_STANDARD</a>;
}
</pre></div><p>Custom GUI-control to edit colorvalues. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CColorControl : <span class="keyword">public</span> gui::IGUIElement
{
<span class="keyword">public</span>:
    <span class="comment">// Constructor</span>
    CColorControl(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *text, IGUIElement* parent, <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> <span class="keywordtype">id</span>=-1 )
        : gui::IGUIElement(gui::<a class="code" href="namespaceirr_1_1gui.html#ae4d66df0ecf4117cdbcf9f22404bd254afab12396466cf3add0f9e7408a053932" title="Unknown type.">EGUIET_ELEMENT</a>, guiEnv, parent,id, core::rect&lt; <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> &gt;(pos, pos+core::dimension2d&lt;<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>&gt;(80, 75)))
        , DirtyFlag(true)
        , ColorStatic(0)
        , EditAlpha(0)
        , EditRed(0)
        , EditGreen(0)
        , EditBlue(0)
    {
        <span class="keyword">using namespace </span>gui;
        ButtonSetId = makeUniqueId();

        <span class="keyword">const</span> core::rect&lt; s32 &gt; rectControls(0,0,AbsoluteRect.getWidth(),AbsoluteRect.getHeight() );
        IGUIStaticText * groupElement = guiEnv-&gt;addStaticText (L<span class="stringliteral">&quot;&quot;</span>, rectControls, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>, -1, <span class="keyword">false</span>);
        groupElement-&gt;setNotClipped(<span class="keyword">true</span>);

        guiEnv-&gt;addStaticText (text, core::rect&lt;s32&gt;(0,0,80,15), <span class="keyword">false</span>, <span class="keyword">false</span>, groupElement, -1, <span class="keyword">false</span>);

        EditAlpha = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,15), L<span class="stringliteral">&quot;a&quot;</span>, -1, groupElement );
        EditRed = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,30), L<span class="stringliteral">&quot;r&quot;</span>, -1, groupElement );
        EditGreen = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,45), L<span class="stringliteral">&quot;g&quot;</span>, -1, groupElement );
        EditBlue = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,60), L<span class="stringliteral">&quot;b&quot;</span>, -1, groupElement );

        ColorStatic = guiEnv-&gt;addStaticText (L<span class="stringliteral">&quot;&quot;</span>, core::rect&lt;s32&gt;(60,15,80,75), <span class="keyword">true</span>, <span class="keyword">false</span>, groupElement, -1, <span class="keyword">true</span>);

        guiEnv-&gt;addButton (core::rect&lt;s32&gt;(60,35,80,50), groupElement, ButtonSetId, L<span class="stringliteral">&quot;set&quot;</span>);
        SetEditsFromColor(Color);
    }

    <span class="comment">// event receiver</span>
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent &amp;event)
    {
        <span class="keywordflow">if</span> ( event.EventType != <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0cae85bb44dd09a29c879d64a05047fc1d2" title="An event of the graphical user interface.">EET_GUI_EVENT</a> )
            <span class="keywordflow">return</span> <span class="keyword">false</span>;

        <span class="keywordflow">if</span> ( event.GUIEvent.Caller-&gt;getID() == ButtonSetId &amp;&amp; <span class="keyword">event</span>.GUIEvent.EventType == <a class="code" href="namespaceirr_1_1gui.html#aeac71ad17341a4b6e9026ae11d576808a308ee345c92444931f83e48354072d98" title="A button was clicked.">gui::EGET_BUTTON_CLICKED</a> )
        {
            Color = GetColorFromEdits();
            SetEditsFromColor(Color);
        }

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// set the color values</span>
    <span class="keywordtype">void</span> setColor(<span class="keyword">const</span> video::SColor&amp; col)
    {
        DirtyFlag = <span class="keyword">true</span>;
        Color = col;
        SetEditsFromColor(Color);
    }

    <span class="comment">// get the color values</span>
    <span class="keyword">const</span> video::SColor&amp; getColor()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> Color;
    }

    <span class="comment">// To reset the dirty flag</span>
    <span class="keywordtype">void</span> resetDirty()
    {
        DirtyFlag = <span class="keyword">false</span>;
    }

    <span class="comment">// when the color was changed the dirty flag is set</span>
    <span class="keywordtype">bool</span> isDirty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> DirtyFlag;
    };

<span class="keyword">protected</span>:

    <span class="comment">// Add a staticbox for a description + an editbox so users can enter numbers</span>
    gui::IGUIEditBox* addEditForNumbers(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *text, <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> <span class="keywordtype">id</span>, gui::IGUIElement * parent)
    {
        <span class="keyword">using namespace </span>gui;

        core::rect&lt; s32 &gt; rect(pos, pos+core::dimension2d&lt;s32&gt;(10, 15));
        guiEnv-&gt;addStaticText (text, rect, <span class="keyword">false</span>, <span class="keyword">false</span>, parent, -1, <span class="keyword">false</span>);
        rect += core::position2d&lt;s32&gt;( 20, 0 );
        rect.LowerRightCorner.X += 20;
        gui::IGUIEditBox* edit = guiEnv-&gt;addEditBox(L<span class="stringliteral">&quot;0&quot;</span>, rect, <span class="keyword">true</span>, parent, <span class="keywordtype">id</span>);
        <span class="keywordflow">return</span> edit;
    }

    <span class="comment">// Get the color value from the editfields</span>
    video::SColor GetColorFromEdits()
    {
        video::SColor col;

        <span class="keywordflow">if</span> (EditAlpha)
        {
            <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> alpha = <a class="code" href="namespaceirr_1_1core.html#ae7f759b603f4caaa8471cb9bc2e23648" title="Convert a simple string of base 10 digits into an unsigned 32 bit integer.">core::strtoul10</a>(<a class="code" href="namespaceirr_1_1core.html#ade1071a878633f2f6d8a75c5d11fec19" title="Typedef for character strings.">core::stringc</a>(EditAlpha-&gt;getText()).c_str());
            <span class="keywordflow">if</span> (alpha &gt; 255)
                alpha = 255;
            col.setAlpha(alpha);
        }

        <span class="keywordflow">if</span> (EditRed)
        {
            <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> red = <a class="code" href="namespaceirr_1_1core.html#ae7f759b603f4caaa8471cb9bc2e23648" title="Convert a simple string of base 10 digits into an unsigned 32 bit integer.">core::strtoul10</a>(<a class="code" href="namespaceirr_1_1core.html#ade1071a878633f2f6d8a75c5d11fec19" title="Typedef for character strings.">core::stringc</a>(EditRed-&gt;getText()).c_str());
            <span class="keywordflow">if</span> (red &gt; 255)
                red = 255;
            col.setRed(red);
        }

        <span class="keywordflow">if</span> (EditGreen)
        {
            <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> green = <a class="code" href="namespaceirr_1_1core.html#ae7f759b603f4caaa8471cb9bc2e23648" title="Convert a simple string of base 10 digits into an unsigned 32 bit integer.">core::strtoul10</a>(<a class="code" href="namespaceirr_1_1core.html#ade1071a878633f2f6d8a75c5d11fec19" title="Typedef for character strings.">core::stringc</a>(EditGreen-&gt;getText()).c_str());
            <span class="keywordflow">if</span> (green &gt; 255)
                green = 255;
            col.setGreen(green);
        }

        <span class="keywordflow">if</span> (EditBlue)
        {
            <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> blue = <a class="code" href="namespaceirr_1_1core.html#ae7f759b603f4caaa8471cb9bc2e23648" title="Convert a simple string of base 10 digits into an unsigned 32 bit integer.">core::strtoul10</a>(<a class="code" href="namespaceirr_1_1core.html#ade1071a878633f2f6d8a75c5d11fec19" title="Typedef for character strings.">core::stringc</a>(EditBlue-&gt;getText()).c_str());
            <span class="keywordflow">if</span> (blue &gt; 255)
                blue = 255;
            col.setBlue(blue);
        }

        <span class="keywordflow">return</span> col;
    }

    <span class="comment">// Fill the editfields with the value for the given color</span>
    <span class="keywordtype">void</span> SetEditsFromColor(video::SColor col)
    {
        DirtyFlag = <span class="keyword">true</span>;
        <span class="keywordflow">if</span> ( EditAlpha )
            EditAlpha-&gt;setText( <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a>(col.getAlpha()).c_str() );
        <span class="keywordflow">if</span> ( EditRed )
            EditRed-&gt;setText( <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a>(col.getRed()).c_str() );
        <span class="keywordflow">if</span> ( EditGreen )
            EditGreen-&gt;setText( <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a>(col.getGreen()).c_str() );
        <span class="keywordflow">if</span> ( EditBlue )
            EditBlue-&gt;setText( <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a>(col.getBlue()).c_str() );
        <span class="keywordflow">if</span> ( ColorStatic )
            ColorStatic-&gt;setBackgroundColor(col);
    }

<span class="keyword">private</span>:

    <span class="keywordtype">bool</span> DirtyFlag;
    video::SColor Color;
    <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> ButtonSetId;
    gui::IGUIStaticText * ColorStatic;
    gui::IGUIEditBox * EditAlpha;
    gui::IGUIEditBox * EditRed;
    gui::IGUIEditBox * EditGreen;
    gui::IGUIEditBox * EditBlue;
};
</pre></div><p>Custom GUI-control for to edit all colors typically used in materials and lights </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CAllColorsControl : <span class="keyword">public</span> gui::IGUIElement
{
<span class="keyword">public</span>:
    <span class="comment">// Constructor</span>
    CAllColorsControl(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * description, <span class="keywordtype">bool</span> hasEmissive, IGUIElement* parent, <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> <span class="keywordtype">id</span>=-1)
        : gui::IGUIElement(gui::<a class="code" href="namespaceirr_1_1gui.html#ae4d66df0ecf4117cdbcf9f22404bd254afab12396466cf3add0f9e7408a053932" title="Unknown type.">EGUIET_ELEMENT</a>, guiEnv, parent,id, core::rect&lt;<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>&gt;(pos,pos+core::dimension2d&lt;<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>&gt;(60,250)))
        , ControlAmbientColor(0), ControlDiffuseColor(0), ControlSpecularColor(0), ControlEmissiveColor(0)
    {
        core::rect&lt;s32&gt; rect(0, 0, 60, 15);
        guiEnv-&gt;addStaticText (description, rect, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">this</span>, -1, <span class="keyword">false</span>);
        createColorControls(guiEnv, core::position2d&lt;s32&gt;(0, 15), hasEmissive);
    }

    <span class="comment">// Destructor</span>
    <span class="keyword">virtual</span> ~CAllColorsControl()
    {
        ControlAmbientColor-&gt;drop();
        ControlDiffuseColor-&gt;drop();
        <span class="keywordflow">if</span> ( ControlEmissiveColor )
            ControlEmissiveColor-&gt;drop();
        ControlSpecularColor-&gt;drop();
    }

    <span class="comment">// Set the color values to those within the material</span>
    <span class="keywordtype">void</span> setColorsToMaterialColors(<span class="keyword">const</span> video::SMaterial &amp; material)
    {
        ControlAmbientColor-&gt;setColor(material.AmbientColor);
        ControlDiffuseColor-&gt;setColor(material.DiffuseColor);
        ControlEmissiveColor-&gt;setColor(material.EmissiveColor);
        ControlSpecularColor-&gt;setColor(material.SpecularColor);
    }

    <span class="comment">// Update all changed colors in the material</span>
    <span class="keywordtype">void</span> updateMaterialColors(video::SMaterial &amp; material)
    {
        <span class="keywordflow">if</span> ( ControlAmbientColor-&gt;isDirty() )
            material.AmbientColor = ControlAmbientColor-&gt;getColor();
        <span class="keywordflow">if</span> ( ControlDiffuseColor-&gt;isDirty() )
            material.DiffuseColor = ControlDiffuseColor-&gt;getColor();
        <span class="keywordflow">if</span> ( ControlEmissiveColor-&gt;isDirty() )
            material.EmissiveColor = ControlEmissiveColor-&gt;getColor();
        <span class="keywordflow">if</span> ( ControlSpecularColor-&gt;isDirty() )
            material.SpecularColor = ControlSpecularColor-&gt;getColor();
    }

    <span class="comment">// Set the color values to those from the light data</span>
    <span class="keywordtype">void</span> setColorsToLightDataColors(<span class="keyword">const</span> video::SLight &amp; lightData)
    {
        ControlAmbientColor-&gt;setColor(lightData.AmbientColor.toSColor());
        ControlAmbientColor-&gt;setColor(lightData.DiffuseColor.toSColor());
        ControlAmbientColor-&gt;setColor(lightData.SpecularColor.toSColor());
    }

    <span class="comment">// Update all changed colors in the light data</span>
    <span class="keywordtype">void</span> updateLightColors(video::SLight &amp; lightData)
    {
        <span class="keywordflow">if</span> ( ControlAmbientColor-&gt;isDirty() )
            lightData.AmbientColor = video::SColorf( ControlAmbientColor-&gt;getColor() );
        <span class="keywordflow">if</span> ( ControlDiffuseColor-&gt;isDirty() )
            lightData.DiffuseColor = video::SColorf( ControlDiffuseColor-&gt;getColor() );
        <span class="keywordflow">if</span> ( ControlSpecularColor-&gt;isDirty() )
            lightData.SpecularColor = video::SColorf(ControlSpecularColor-&gt;getColor() );
    }

    <span class="comment">// To reset the dirty flags</span>
    <span class="keywordtype">void</span> resetDirty()
    {
        ControlAmbientColor-&gt;resetDirty();
        ControlDiffuseColor-&gt;resetDirty();
        ControlSpecularColor-&gt;resetDirty();
        <span class="keywordflow">if</span> ( ControlEmissiveColor )
            ControlEmissiveColor-&gt;resetDirty();
    }

<span class="keyword">protected</span>:
    <span class="keywordtype">void</span> createColorControls(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keywordtype">bool</span> hasEmissive)
    {
        ControlAmbientColor = <span class="keyword">new</span> CColorControl( guiEnv, pos, L<span class="stringliteral">&quot;ambient&quot;</span>, <span class="keyword">this</span>);
        ControlDiffuseColor = <span class="keyword">new</span> CColorControl( guiEnv, pos + core::position2d&lt;s32&gt;(0, 75), L<span class="stringliteral">&quot;diffuse&quot;</span>, <span class="keyword">this</span> );
        ControlSpecularColor = <span class="keyword">new</span> CColorControl( guiEnv, pos + core::position2d&lt;s32&gt;(0, 150), L<span class="stringliteral">&quot;specular&quot;</span>, <span class="keyword">this</span> );
        <span class="keywordflow">if</span> ( hasEmissive )
        {
            ControlEmissiveColor = <span class="keyword">new</span> CColorControl( guiEnv, pos + core::position2d&lt;s32&gt;(0, 225), L<span class="stringliteral">&quot;emissive&quot;</span>, <span class="keyword">this</span> );
        }
    }

<span class="keyword">private</span>:
    CColorControl*  ControlAmbientColor;
    CColorControl*  ControlDiffuseColor;
    CColorControl*  ControlSpecularColor;
    CColorControl*  ControlEmissiveColor;
};
</pre></div><p>GUI-Control to offer a selection of available textures. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CTextureControl : <span class="keyword">public</span> gui::IGUIElement
{
<span class="keyword">public</span>:
    CTextureControl(gui::IGUIEnvironment* guiEnv, video::IVideoDriver * driver, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, IGUIElement* parent, <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> <span class="keywordtype">id</span>=-1)
    : gui::IGUIElement(gui::<a class="code" href="namespaceirr_1_1gui.html#ae4d66df0ecf4117cdbcf9f22404bd254afab12396466cf3add0f9e7408a053932" title="Unknown type.">EGUIET_ELEMENT</a>, guiEnv, parent,id, core::rect&lt;<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>&gt;(pos,pos+core::dimension2d&lt;<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>&gt;(100,15)))
    , DirtyFlag(true), ComboTexture(0)
    {
        core::rect&lt;s32&gt; rectCombo(0, 0, AbsoluteRect.getWidth(),AbsoluteRect.getHeight());
        ComboTexture = guiEnv-&gt;addComboBox (rectCombo, <span class="keyword">this</span>);
        updateTextures(driver);
    }

    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent &amp;event)
    {
        <span class="keywordflow">if</span> ( event.EventType != <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0cae85bb44dd09a29c879d64a05047fc1d2" title="An event of the graphical user interface.">EET_GUI_EVENT</a> )
            <span class="keywordflow">return</span> <span class="keyword">false</span>;

        <span class="keywordflow">if</span> ( event.GUIEvent.Caller == ComboTexture &amp;&amp; event.GUIEvent.EventType == <a class="code" href="namespaceirr_1_1gui.html#aeac71ad17341a4b6e9026ae11d576808aef7f9081622a71160e161c80eb07d436" title="The selection in a combo box has been changed.">gui::EGET_COMBO_BOX_CHANGED</a> )
        {
            DirtyFlag = <span class="keyword">true</span>;
        }

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// Workaround for a problem with comboboxes.</span>
    <span class="comment">// We have to get in front when the combobox wants to get in front or combobox-list might be drawn below other elements.</span>
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> bringToFront(IGUIElement* element)
    {
        <span class="keywordtype">bool</span> result = gui::IGUIElement::bringToFront(element);
        <span class="keywordflow">if</span> ( Parent &amp;&amp; element == ComboTexture )
            result &amp;= Parent-&gt;bringToFront(<span class="keyword">this</span>);
        <span class="keywordflow">return</span> result;
    }

    <span class="comment">// return selected texturename (if any, otherwise 0)</span>
    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * getSelectedTextureName()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> selected = ComboTexture-&gt;getSelected();
        <span class="keywordflow">if</span> ( selected &lt; 0 )
            <span class="keywordflow">return</span> 0;
        <span class="keywordflow">return</span> ComboTexture-&gt;getItem(selected);
    }

    <span class="comment">// reset the dirty flag</span>
    <span class="keywordtype">void</span> resetDirty()
    {
        DirtyFlag = <span class="keyword">false</span>;
    }

    <span class="comment">// when the texture was changed the dirty flag is set</span>
    <span class="keywordtype">bool</span> isDirty()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> DirtyFlag;
    };

    <span class="comment">// Put the names of all currently loaded textures in a combobox</span>
    <span class="keywordtype">void</span> updateTextures(video::IVideoDriver * driver)
    {
        <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> oldSelected = ComboTexture-&gt;getSelected();
        <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> selectNew = -1;
        <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * oldTextureName = 0;
        <span class="keywordflow">if</span> ( oldSelected &gt;= 0 )
        {
            oldTextureName = ComboTexture-&gt;getItem(oldSelected);
        }
        ComboTexture-&gt;clear();
        <span class="keywordflow">for</span> ( <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> i=0; i &lt; driver-&gt;getTextureCount(); ++i )
        {
            video::ITexture * texture = driver-&gt;getTextureByIndex(i);
            <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a> name( texture-&gt;getName() );
            ComboTexture-&gt;addItem( name.c_str() );
            <span class="keywordflow">if</span> ( oldTextureName &amp;&amp; selectNew &lt; 0 &amp;&amp; name == oldTextureName )
                selectNew = i;
        }

        <span class="comment">// add another name which can be used to clear the texture</span>
        ComboTexture-&gt;addItem( CLEAR_TEXTURE.c_str() );
        <span class="keywordflow">if</span> ( CLEAR_TEXTURE == oldTextureName )
            selectNew = ComboTexture-&gt;getItemCount()-1;

        <span class="keywordflow">if</span> ( selectNew &gt;= 0 )
            ComboTexture-&gt;setSelected(selectNew);

        DirtyFlag = <span class="keyword">true</span>;
    }

<span class="keyword">private</span>:
    <span class="keywordtype">bool</span> DirtyFlag;
    gui::IGUIComboBox * ComboTexture;
};
</pre></div><p>Control which allows setting some of the material values for a meshscenenode </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>SMeshNodeControl
{
    <span class="comment">// constructor</span>
    SMeshNodeControl()
        : Initialized(false), Driver(0), MeshManipulator(0), SceneNode(0), SceneNode2T(0), SceneNodeTangents(0)
        , AllColorsControl(0), ButtonLighting(0), InfoLighting(0), ComboMaterial(0), TextureControl1(0), TextureControl2(0), ControlVertexColors(0)
    {
    }

    <span class="comment">// Destructor</span>
    <span class="keyword">virtual</span> ~SMeshNodeControl()
    {
        <span class="keywordflow">if</span> ( TextureControl1 )
            TextureControl1-&gt;drop();
        <span class="keywordflow">if</span> ( TextureControl2 )
            TextureControl2-&gt;drop();
        <span class="keywordflow">if</span> ( ControlVertexColors )
            ControlVertexColors-&gt;drop();
        <span class="keywordflow">if</span> ( AllColorsControl )
            AllColorsControl-&gt;drop();
    }

    <span class="keywordtype">void</span> init(scene::IMeshSceneNode* node, IrrlichtDevice * device, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * description)
    {
        <span class="keywordflow">if</span> ( Initialized || !node || !device) <span class="comment">// initializing twice or with invalid data not allowed</span>
            <span class="keywordflow">return</span>;

        Driver = device-&gt;getVideoDriver ();
        gui::IGUIEnvironment* guiEnv = device-&gt;getGUIEnvironment();
        scene::ISceneManager* smgr = device-&gt;getSceneManager();
        MeshManipulator = smgr-&gt;getMeshManipulator();

        SceneNode = node;
        scene::IMeshManipulator * meshManip = smgr-&gt;getMeshManipulator();

        scene::IMesh * mesh2T = meshManip-&gt;createMeshWith2TCoords(node-&gt;getMesh());
        SceneNode2T = smgr-&gt;addMeshSceneNode(mesh2T, 0, -1, SceneNode-&gt;getPosition(), SceneNode-&gt;getRotation(), SceneNode-&gt;getScale() );
        mesh2T-&gt;drop();

        scene::IMesh * meshTangents = meshManip-&gt;createMeshWithTangents(node-&gt;getMesh(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
        SceneNodeTangents = smgr-&gt;addMeshSceneNode(meshTangents, 0, -1
                                            , SceneNode-&gt;getPosition(), SceneNode-&gt;getRotation(), SceneNode-&gt;getScale() );
        meshTangents-&gt;drop();

        video::SMaterial &amp; material = SceneNode-&gt;getMaterial(0);
        material.Lighting = <span class="keyword">true</span>;
        AllColorsControl = <span class="keyword">new</span> CAllColorsControl(guiEnv, pos, description, <span class="keyword">true</span>, guiEnv-&gt;getRootGUIElement());
        AllColorsControl-&gt;setColorsToMaterialColors(material);

        core::rect&lt;s32&gt; rectBtn(pos + core::position2d&lt;s32&gt;(0, 320), core::dimension2d&lt;s32&gt;(60, 15));
        ButtonLighting = guiEnv-&gt;addButton (rectBtn, 0, -1, L<span class="stringliteral">&quot;Lighting&quot;</span>);
        ButtonLighting-&gt;setIsPushButton(<span class="keyword">true</span>);
        ButtonLighting-&gt;setPressed(material.Lighting);
        core::rect&lt;s32&gt; rectInfo( rectBtn.LowerRightCorner.X, rectBtn.UpperLeftCorner.Y, rectBtn.LowerRightCorner.X+40, rectBtn.UpperLeftCorner.Y+15 );
        InfoLighting = guiEnv-&gt;addStaticText(L<span class="stringliteral">&quot;&quot;</span>, rectInfo, <span class="keyword">true</span>, <span class="keyword">false</span> );
        InfoLighting-&gt;setTextAlignment(<a class="code" href="namespaceirr_1_1gui.html#a19eb5fb40e67f108cb16aba922ddaa2da9da0fb4bcb85d509bdfe018b720e4606" title="Aligned to the center of parent.">gui::EGUIA_CENTER</a>, <a class="code" href="namespaceirr_1_1gui.html#a19eb5fb40e67f108cb16aba922ddaa2da9da0fb4bcb85d509bdfe018b720e4606" title="Aligned to the center of parent.">gui::EGUIA_CENTER</a> );

        core::rect&lt;s32&gt; rectCombo(pos.X, rectBtn.LowerRightCorner.Y, pos.X+100, rectBtn.LowerRightCorner.Y+15);
        ComboMaterial = guiEnv-&gt;addComboBox (rectCombo);
        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i &lt;= (int)<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a09498eaf291e1f7abdc04db808cc15d9" title="BlendFunc = source * sourceFactor + dest * destFactor ( E_BLEND_FUNC )">video::EMT_ONETEXTURE_BLEND</a>; ++i )
        {
            ComboMaterial-&gt;addItem( <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a>(<a class="code" href="namespaceirr_1_1video.html#a833460ba01098710b6df3ec5c281c873" title="Array holding the built in material type names.">video::sBuiltInMaterialTypeNames</a>[i]).c_str() );
        }
        ComboMaterial-&gt;setSelected( (<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>)material.MaterialType );

        core::position2d&lt;s32&gt; posTex(rectCombo.UpperLeftCorner.X,rectCombo.LowerRightCorner.Y);
        TextureControl1 = <span class="keyword">new</span> CTextureControl(guiEnv, Driver, posTex, guiEnv-&gt;getRootGUIElement());
        posTex.Y += 15;
        TextureControl2 = <span class="keyword">new</span> CTextureControl(guiEnv, Driver, posTex, guiEnv-&gt;getRootGUIElement());

        core::position2d&lt;s32&gt; posVertexColors( posTex.X, posTex.Y + 15);
        ControlVertexColors = <span class="keyword">new</span> CColorControl( guiEnv, posVertexColors, L<span class="stringliteral">&quot;Vertex colors&quot;</span>, guiEnv-&gt;getRootGUIElement());

        video::S3DVertex * vertices =  (video::S3DVertex *)node-&gt;getMesh()-&gt;getMeshBuffer(0)-&gt;getVertices();
        <span class="keywordflow">if</span> ( vertices )
        {
            ControlVertexColors-&gt;setColor(vertices[0].Color);
        }

        Initialized = <span class="keyword">true</span>;
    }

    <span class="keywordtype">void</span> update()
    {
        <span class="keywordflow">if</span> ( !Initialized )
            <span class="keywordflow">return</span>;

        video::SMaterial &amp; material = SceneNode-&gt;getMaterial(0);
        video::SMaterial &amp; material2T = SceneNode2T-&gt;getMaterial(0);
        video::SMaterial &amp; materialTangents = SceneNodeTangents-&gt;getMaterial(0);

        <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> selectedMaterial = ComboMaterial-&gt;getSelected();
        <span class="keywordflow">if</span> ( selectedMaterial &gt;= (<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>)<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a9bc471b9c18c9e2d20496004d2a2e803" title="Standard solid material.">video::EMT_SOLID</a> &amp;&amp; selectedMaterial &lt;= (<a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a>)<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1a09498eaf291e1f7abdc04db808cc15d9" title="BlendFunc = source * sourceFactor + dest * destFactor ( E_BLEND_FUNC )">video::EMT_ONETEXTURE_BLEND</a>)
        {
            <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deac" title="Enumeration for all vertex types there are.">video::E_VERTEX_TYPE</a> vertexType = getVertexTypeForMaterialType((<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a>)selectedMaterial);
            <span class="keywordflow">switch</span> ( vertexType )
            {
                <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca98c8b791280bbf9252c4f4a37e91a416" title="Standard vertex type used by the Irrlicht engine, video::S3DVertex.">video::EVT_STANDARD</a>:
                    material.MaterialType = (<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a>)selectedMaterial;
                    SceneNode-&gt;setVisible(<span class="keyword">true</span>);
                    SceneNode2T-&gt;setVisible(<span class="keyword">false</span>);
                    SceneNodeTangents-&gt;setVisible(<span class="keyword">false</span>);
                    <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca7b5127a706ee33eb4385d702da007016" title="Vertex with two texture coordinates, video::S3DVertex2TCoords.">video::EVT_2TCOORDS</a>:
                    material2T.MaterialType = (<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a>)selectedMaterial;
                    SceneNode-&gt;setVisible(<span class="keyword">false</span>);
                    SceneNode2T-&gt;setVisible(<span class="keyword">true</span>);
                    SceneNodeTangents-&gt;setVisible(<span class="keyword">false</span>);
                    <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1video.html#a0e3b59e025e0d0db0ed2ee0ce904deaca8c50b5b2c88f08709d640fecc83dfb9b" title="Vertex with a tangent and binormal vector, video::S3DVertexTangents.">video::EVT_TANGENTS</a>:
                    materialTangents.MaterialType = (<a class="code" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1" title="Abstracted and easy to use fixed function/programmable pipeline material modes.">video::E_MATERIAL_TYPE</a>)selectedMaterial;
                    SceneNode-&gt;setVisible(<span class="keyword">false</span>);
                    SceneNode2T-&gt;setVisible(<span class="keyword">false</span>);
                    SceneNodeTangents-&gt;setVisible(<span class="keyword">true</span>);
                    <span class="keywordflow">break</span>;
            }
        }

        updateMaterial(material);
        updateMaterial(material2T);
        updateMaterial(materialTangents);

        <span class="keywordflow">if</span> ( ButtonLighting-&gt;isPressed() )
            InfoLighting-&gt;setText(L<span class="stringliteral">&quot;on&quot;</span>);
        <span class="keywordflow">else</span>
            InfoLighting-&gt;setText(L<span class="stringliteral">&quot;off&quot;</span>);

        AllColorsControl-&gt;resetDirty();
        TextureControl1-&gt;resetDirty();
        TextureControl2-&gt;resetDirty();
        ControlVertexColors-&gt;resetDirty();
    }

    <span class="keywordtype">void</span> updateTextures()
    {
        TextureControl1-&gt;updateTextures(Driver);
        TextureControl2-&gt;updateTextures(Driver);
    }

<span class="keyword">protected</span>:

    <span class="keywordtype">void</span> updateMaterial(video::SMaterial &amp; material)
    {
        AllColorsControl-&gt;updateMaterialColors(material);
        material.Lighting = ButtonLighting-&gt;isPressed();
        <span class="keywordflow">if</span> ( TextureControl1-&gt;isDirty() )
        {
            material.TextureLayer[0].Texture = Driver-&gt;getTexture( <a class="code" href="namespaceirr_1_1io.html#ab1bdc45edb3f94d8319c02bc0f840ee1" title="Type used for all file system related strings.">io::path</a>(TextureControl1-&gt;getSelectedTextureName()) );
        }
        <span class="keywordflow">if</span> ( TextureControl2-&gt;isDirty() )
        {
            material.TextureLayer[1].Texture = Driver-&gt;getTexture( <a class="code" href="namespaceirr_1_1io.html#ab1bdc45edb3f94d8319c02bc0f840ee1" title="Type used for all file system related strings.">io::path</a>(TextureControl2-&gt;getSelectedTextureName()) );
        }
        <span class="keywordflow">if</span> ( ControlVertexColors-&gt;isDirty() )
        {
            MeshManipulator-&gt;setVertexColors (SceneNode-&gt;getMesh(), ControlVertexColors-&gt;getColor());
            MeshManipulator-&gt;setVertexColors (SceneNode2T-&gt;getMesh(), ControlVertexColors-&gt;getColor());
            MeshManipulator-&gt;setVertexColors (SceneNodeTangents-&gt;getMesh(), ControlVertexColors-&gt;getColor());
        }
    }

    <span class="keywordtype">bool</span> Initialized;
    video::IVideoDriver *       Driver;
    scene::IMeshManipulator*    MeshManipulator;
    scene::IMeshSceneNode*      SceneNode;
    scene::IMeshSceneNode*      SceneNode2T;
    scene::IMeshSceneNode*      SceneNodeTangents;
    CAllColorsControl*          AllColorsControl;
    gui::IGUIButton *           ButtonLighting;
    gui::IGUIStaticText*        InfoLighting;
    gui::IGUIComboBox *         ComboMaterial;
    CTextureControl*            TextureControl1;
    CTextureControl*            TextureControl2;
    CColorControl*              ControlVertexColors;
};
</pre></div><p>Control to allow setting the color values of a lightscenenode. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>SLightNodeControl
{
    <span class="comment">// constructor</span>
    SLightNodeControl() : Initialized(false), SceneNode(0), AllColorsControl(0)
    {
    }

    <span class="keyword">virtual</span> ~SLightNodeControl()
    {
        <span class="keywordflow">if</span> ( AllColorsControl )
            AllColorsControl-&gt;drop();
    }

    <span class="keywordtype">void</span> init(scene::ILightSceneNode* node, gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * description)
    {
        <span class="keywordflow">if</span> ( Initialized || !node || !guiEnv) <span class="comment">// initializing twice or with invalid data not allowed</span>
            <span class="keywordflow">return</span>;
        SceneNode = node;
        AllColorsControl = <span class="keyword">new</span> CAllColorsControl(guiEnv, pos, description, <span class="keyword">false</span>, guiEnv-&gt;getRootGUIElement());
        <span class="keyword">const</span> video::SLight &amp; lightData = SceneNode-&gt;getLightData();
        AllColorsControl-&gt;setColorsToLightDataColors(lightData);
        Initialized = <span class="keyword">true</span>;
    }

    <span class="keywordtype">void</span> update()
    {
        <span class="keywordflow">if</span> ( !Initialized )
            <span class="keywordflow">return</span>;

        video::SLight &amp; lightData = SceneNode-&gt;getLightData();
        AllColorsControl-&gt;updateLightColors(lightData);
    }

<span class="keyword">protected</span>:
    <span class="keywordtype">bool</span> Initialized;
    scene::ILightSceneNode* SceneNode;
    CAllColorsControl* AllColorsControl;
};
</pre></div><p>Application configuration </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>SConfig
{
    SConfig()
    : RenderInBackground(true)
    , DriverType(video::<a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0ae85481da26159b967191ccc6de1e4a05" title="The Burning&#39;s Software Renderer, an alternative software renderer.">EDT_BURNINGSVIDEO</a>)
    , ScreenSize(640, 480)
    {
    }

    <span class="keywordtype">bool</span> RenderInBackground;
    <a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0" title="An enum for all types of drivers the Irrlicht Engine supports.">video::E_DRIVER_TYPE</a> DriverType;
    core::dimension2d&lt;u32&gt; ScreenSize;
};
</pre></div><p>Main application class </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CApp : <span class="keyword">public</span> IEventReceiver
{
    <span class="keyword">friend</span> <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]);

<span class="keyword">public</span>:
    <span class="comment">// constructor</span>
    CApp()
    : IsRunning(false)
    , Device(0)
    , Camera(0)
    , GlobalAmbient(0)
    {
    }

    <span class="comment">// destructor</span>
    ~CApp()
    {
    }

    <span class="comment">// stop running - will quit at end of mainloop</span>
    <span class="keywordtype">void</span> stopApp()
    {
        IsRunning = <span class="keyword">false</span>;
    }

    <span class="comment">// Event handler</span>
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent &amp;event)
    {
        <span class="keywordflow">if</span> (event.EventType == <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0cae85bb44dd09a29c879d64a05047fc1d2" title="An event of the graphical user interface.">EET_GUI_EVENT</a>)
        {
            gui::IGUIEnvironment* env = Device-&gt;getGUIEnvironment();

            <span class="keywordflow">switch</span>(event.GUIEvent.EventType)
            {
                <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1gui.html#aeac71ad17341a4b6e9026ae11d576808a90e8bebdd49f2a2e451b1105a87ee7ef" title="A menu item was selected in a (context) menu.">gui::EGET_MENU_ITEM_SELECTED</a>:
                {
                    gui::IGUIContextMenu* menu = (gui::IGUIContextMenu*)event.GUIEvent.Caller;
                    <a class="code" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6" title="32 bit signed variable.">s32</a> <span class="keywordtype">id</span> = menu-&gt;getItemCommandId(menu-&gt;getSelectedItem());

                    <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>)
                    {
                        <span class="keywordflow">case</span> GUI_ID_OPEN_TEXTURE: <span class="comment">// File -&gt; Open Texture</span>
                            env-&gt;addFileOpenDialog(L<span class="stringliteral">&quot;Please select a texture file to open&quot;</span>);
                        <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> GUI_ID_QUIT: <span class="comment">// File -&gt; Quit</span>
                            stopApp();
                        <span class="keywordflow">break</span>;
                    }
                }
                <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> <a class="code" href="namespaceirr_1_1gui.html#aeac71ad17341a4b6e9026ae11d576808a5b6504cf6b541d5ad95407c384632873" title="A file has been selected in the file dialog.">gui::EGET_FILE_SELECTED</a>:
                {
                    <span class="comment">// load the model file, selected in the file open dialog</span>
                    gui::IGUIFileOpenDialog* dialog =
                        (gui::IGUIFileOpenDialog*)event.GUIEvent.Caller;
                    loadTexture(<a class="code" href="namespaceirr_1_1io.html#ab1bdc45edb3f94d8319c02bc0f840ee1" title="Type used for all file system related strings.">io::path</a>(dialog-&gt;getFileName()).c_str());
                }
                <span class="keywordflow">break</span>;

                <span class="keywordflow">default</span>:
                <span class="keywordflow">break</span>;
            }
        }

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

<span class="keyword">protected</span>:

    <span class="comment">// Application initialization</span>
    <span class="comment">// returns true when it was successful initialized, otherwise false.</span>
    <span class="keywordtype">bool</span> init(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
    {
        <span class="comment">// ask user for driver</span>
        Config.DriverType=driverChoiceConsole();
        <span class="keywordflow">if</span> (Config.DriverType==<a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0ae685cada50f8c100403134d932d0414c" title="No driver, just for counting the elements.">video::EDT_COUNT</a>)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;

        <span class="comment">// create the device with the settings from our config</span>
        Device = <a class="code" href="namespaceirr.html#abaf4d8719cc26b0d30813abf85e47c76" title="Creates an Irrlicht device. The Irrlicht device is the root object for using the engine.">createDevice</a>(Config.DriverType, Config.ScreenSize);
        <span class="keywordflow">if</span> (!Device)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        Device-&gt;setWindowCaption( DriverTypeNames[Config.DriverType] );
        Device-&gt;setEventReceiver(<span class="keyword">this</span>);

        scene::ISceneManager* smgr = Device-&gt;getSceneManager();
        video::IVideoDriver * driver = Device-&gt;getVideoDriver ();
        gui::IGUIEnvironment* guiEnv = Device-&gt;getGUIEnvironment();

        <span class="comment">// set a nicer font</span>
        gui::IGUISkin* skin = guiEnv-&gt;getSkin();
        gui::IGUIFont* font = guiEnv-&gt;getFont(<span class="stringliteral">&quot;../../media/fonthaettenschweiler.bmp&quot;</span>);
        <span class="keywordflow">if</span> (font)
            skin-&gt;setFont(font);

        <span class="comment">// remove some alpha value because it makes those menus harder to read otherwise</span>
        video::SColor col3dHighLight( skin-&gt;getColor(<a class="code" href="namespaceirr_1_1gui.html#abd15860fde29833c48daff5f95d5467aa130f7af380737d820220cc59a716b04d" title="Background color of multiple document interface (MDI) applications.">gui::EGDC_APP_WORKSPACE</a>) );
        col3dHighLight.setAlpha(255);
        video::SColor colHighLight( col3dHighLight );
        skin-&gt;setColor(<a class="code" href="namespaceirr_1_1gui.html#abd15860fde29833c48daff5f95d5467aa1a7a2f4f13165eee4772e76f11866cbd" title="Item(s) selected in a control.">gui::EGDC_HIGH_LIGHT</a>, colHighLight );
        skin-&gt;setColor(<a class="code" href="namespaceirr_1_1gui.html#abd15860fde29833c48daff5f95d5467aa1227b2c3a809d139e1ead87aa29fa101" title="Highlight color for three-dimensional display elements (for edges facing the light source...">gui::EGDC_3D_HIGH_LIGHT</a>, col3dHighLight );

        <span class="comment">// Add some textures which are useful to test material settings</span>
        createDefaultTextures(driver);

        <span class="comment">// create a menu</span>
        gui::IGUIContextMenu * menuBar = guiEnv-&gt;addMenu();
        menuBar-&gt;addItem(L<span class="stringliteral">&quot;File&quot;</span>, -1, <span class="keyword">true</span>, <span class="keyword">true</span>);

        gui::IGUIContextMenu* subMenuFile = menuBar-&gt;getSubMenu(0);
        subMenuFile-&gt;addItem(L<span class="stringliteral">&quot;Open texture ...&quot;</span>, GUI_ID_OPEN_TEXTURE);
        subMenuFile-&gt;addSeparator();
        subMenuFile-&gt;addItem(L<span class="stringliteral">&quot;Quit&quot;</span>, GUI_ID_QUIT);

        <span class="comment">// a static camera</span>
        Camera = smgr-&gt;addCameraSceneNode (0, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 0),
                                            <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 100),
                                            -1);

        <span class="comment">// add the nodes which are used to show the materials</span>
        scene::IMeshSceneNode* nodeL = smgr-&gt;addCubeSceneNode (30.0f, 0, -1,
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(-35, 0, 100),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 0),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(1.0f, 1.0f, 1.0f));
        NodeLeft.init( nodeL, Device, core::position2d&lt;s32&gt;(10,20), L<span class="stringliteral">&quot;left node&quot;</span> );

        scene::IMeshSceneNode* nodeR = smgr-&gt;addCubeSceneNode (30.0f, 0, -1,
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(35, 0, 100),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 0),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(1.0f, 1.0f, 1.0f));
        NodeRight.init( nodeR, Device, core::position2d&lt;s32&gt;(530,20), L<span class="stringliteral">&quot;right node&quot;</span> );

        <span class="comment">// add one light</span>
        scene::ILightSceneNode* nodeLight = smgr-&gt;addLightSceneNode(0, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 0),
                                                        video::SColorf(1.0f, 1.0f, 1.0f),
                                                        100.0f);
        LightControl.init(nodeLight, guiEnv, core::position2d&lt;s32&gt;(270,20), L<span class="stringliteral">&quot;light&quot;</span> );

        <span class="comment">// one large cube around everything. That&#39;s mainly to make the light more obvious.</span>
        scene::IMeshSceneNode* backgroundCube = smgr-&gt;addCubeSceneNode (200.0f, 0, -1, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, 0),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(45, 0, 0),
                                           <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(1.0f, 1.0f, 1.0f));
        backgroundCube-&gt;getMaterial(0).BackfaceCulling = <span class="keyword">false</span>;         <span class="comment">// we are within the cube, so we have to disable backface culling to see it</span>
        backgroundCube-&gt;getMaterial(0).EmissiveColor.set(255,50,50,50); <span class="comment">// we keep some self lighting to keep texts visible</span>

        <span class="comment">// set the ambient light value</span>
        GlobalAmbient = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(270, 300), L<span class="stringliteral">&quot;global ambient&quot;</span>, guiEnv-&gt;getRootGUIElement());
        GlobalAmbient-&gt;setColor( smgr-&gt;getAmbientLight().toSColor() );

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// Update one frame</span>
    <span class="keywordtype">bool</span> update()
    {
        <span class="keyword">using namespace </span>irr;

        <a class="code" href="classirr_1_1video_1_1_i_video_driver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions.">video::IVideoDriver</a>* videoDriver =  Device-&gt;getVideoDriver();
        <span class="keywordflow">if</span> ( !Device-&gt;run() )
            <span class="keywordflow">return</span> <span class="keyword">false</span>;

        <span class="keywordflow">if</span> ( Device-&gt;isWindowActive() || Config.RenderInBackground )
        {
            <a class="code" href="classirr_1_1gui_1_1_i_g_u_i_environment.html" title="GUI Environment. Used as factory and manager of all other GUI elements.">gui::IGUIEnvironment</a>* guiEnv = Device-&gt;getGUIEnvironment();
            <a class="code" href="classirr_1_1scene_1_1_i_scene_manager.html" title="The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff.">scene::ISceneManager</a>* smgr = Device-&gt;getSceneManager();
            <a class="code" href="classirr_1_1gui_1_1_i_g_u_i_skin.html" title="A skin modifies the look of the GUI elements.">gui::IGUISkin</a> * skin = guiEnv-&gt;<a class="code" href="classirr_1_1gui_1_1_i_g_u_i_environment.html#a54ce9072ea7b89cdaea65306e93ba90c" title="Returns pointer to the current gui skin.">getSkin</a>();

            <span class="comment">// update our controls</span>
            NodeLeft.update();
            NodeRight.update();
            LightControl.update();

            <span class="comment">// update ambient light settings</span>
            <span class="keywordflow">if</span> ( GlobalAmbient-&gt;isDirty() )
            {
                smgr-&gt;<a class="code" href="classirr_1_1scene_1_1_i_scene_manager.html#a8a424accb615c4f60fde59f55033a816" title="Sets ambient color of the scene.">setAmbientLight</a>( GlobalAmbient-&gt;getColor() );
                GlobalAmbient-&gt;resetDirty();
            }

            <span class="comment">// draw everything</span>
            <a class="code" href="classirr_1_1video_1_1_s_color.html" title="Class representing a 32 bit ARGB color.">video::SColor</a> bkColor( skin-&gt;<a class="code" href="classirr_1_1gui_1_1_i_g_u_i_skin.html#ad1afa2e5e34c30e0cbfb85b1dee2dbe3" title="returns default color">getColor</a>(<a class="code" href="namespaceirr_1_1gui.html#abd15860fde29833c48daff5f95d5467aa130f7af380737d820220cc59a716b04d" title="Background color of multiple document interface (MDI) applications.">gui::EGDC_APP_WORKSPACE</a>) );
            videoDriver-&gt;beginScene(<span class="keyword">true</span>, <span class="keyword">true</span>, bkColor);

            smgr-&gt;<a class="code" href="classirr_1_1scene_1_1_i_scene_manager.html#a04240262904667c821bd9de5e5fd9b02" title="Draws all the scene nodes.">drawAll</a>();
            guiEnv-&gt;<a class="code" href="classirr_1_1gui_1_1_i_g_u_i_environment.html#aa6ba29bbf3121a5954cfa5a9ca72982f" title="Draws all gui elements by traversing the GUI environment starting at the root node.">drawAll</a>();

            videoDriver-&gt;endScene();
        }

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// Run the application. Our main loop.</span>
    <span class="keywordtype">void</span> run()
    {
        IsRunning = <span class="keyword">true</span>;

        <span class="keywordflow">if</span> ( !Device )
            <span class="keywordflow">return</span>;

        <span class="comment">// main application loop</span>
        <span class="keywordflow">while</span>(IsRunning)
        {
            <span class="keywordflow">if</span> ( !update() )
                <span class="keywordflow">break</span>;

            Device-&gt;sleep( 5 );
        }
    }

    <span class="comment">// Close down the application</span>
    <span class="keywordtype">void</span> quit()
    {
        IsRunning = <span class="keyword">false</span>;
        GlobalAmbient-&gt;drop();
        GlobalAmbient = NULL;
        <span class="keywordflow">if</span> ( Device )
        {
            Device-&gt;closeDevice();
            Device-&gt;drop();
            Device = NULL;
        }
    }

    <span class="comment">// Create some useful textures.</span>
    <span class="comment">// Note that the function put readability over speed, you shouldn&#39;t use setPixel at runtime but for initialization it&#39;s nice.</span>
    <span class="keywordtype">void</span> createDefaultTextures(<a class="code" href="classirr_1_1video_1_1_i_video_driver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions.">video::IVideoDriver</a> * driver)
    {
        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> width = 256;
        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> height = 256;
        <a class="code" href="classirr_1_1video_1_1_i_image.html" title="Interface for software image data.">video::IImage</a> * imageA8R8G8B8 = driver-&gt;<a class="code" href="classirr_1_1video_1_1_i_video_driver.html#aee1578fdd92118665755f31c0dd1dbb5" title="Creates an empty software image.">createImage</a> (<a class="code" href="namespaceirr_1_1video.html#a1d5e487888c32b1674a8f75116d829eda55c57d63efff39efe33ee733fe962df0" title="Default 32 bit color format. 8 bits are used for every component: red, green, blue and alpha...">video::ECF_A8R8G8B8</a>, <a class="code" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d&lt;u32&gt;</a>(width, height));
        <span class="keywordflow">if</span> ( !imageA8R8G8B8 )
            <span class="keywordflow">return</span>;
        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> pitch = imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#aace497c2d12f217a795a546a735e2675" title="Returns pitch of image.">getPitch</a>();

        <span class="comment">// some nice square-pattern with 9 typical colors</span>
        <span class="keywordflow">for</span> ( <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> y = 0; y &lt; height; ++ y )
        {
            <span class="keywordflow">for</span> ( <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> x = 0; x &lt; pitch; ++x )
            {
                <span class="keywordflow">if</span> ( y &lt; height/3 )
                {
                    <span class="keywordflow">if</span> ( x &lt; width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_BLACK);
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_BLUE);
                    <span class="keywordflow">else</span>
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_CYAN);
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( y &lt; 2*height/3 )
                {
                    <span class="keywordflow">if</span> ( x &lt; width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_GRAY);
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_GREEN);
                    <span class="keywordflow">else</span>
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_MAGENTA);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="keywordflow">if</span> ( x &lt; width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_RED);
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_YELLOW);
                    <span class="keywordflow">else</span>
                        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, SCOL_WHITE);
                }
            }
        }
        driver-&gt;<a class="code" href="classirr_1_1video_1_1_i_video_driver.html#a8c02ee280bb738cdf38b77e7a798244e" title="Creates an empty texture of specified size.">addTexture</a> (<a class="code" href="classirr_1_1core_1_1string.html">io::path</a>(<span class="stringliteral">&quot;CARO_A8R8G8B8&quot;</span>), imageA8R8G8B8);

        <span class="comment">// all white</span>
        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a04973e101790130f611c4c6790e5b352" title="fills the surface with given color">fill</a>(SCOL_WHITE);
        driver-&gt;<a class="code" href="classirr_1_1video_1_1_i_video_driver.html#a8c02ee280bb738cdf38b77e7a798244e" title="Creates an empty texture of specified size.">addTexture</a> (<a class="code" href="classirr_1_1core_1_1string.html">io::path</a>(<span class="stringliteral">&quot;WHITE_A8R8G8B8&quot;</span>), imageA8R8G8B8);

        <span class="comment">// all black</span>
        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a04973e101790130f611c4c6790e5b352" title="fills the surface with given color">fill</a>(SCOL_BLACK);
        driver-&gt;<a class="code" href="classirr_1_1video_1_1_i_video_driver.html#a8c02ee280bb738cdf38b77e7a798244e" title="Creates an empty texture of specified size.">addTexture</a> (<a class="code" href="classirr_1_1core_1_1string.html">io::path</a>(<span class="stringliteral">&quot;BLACK_A8R8G8B8&quot;</span>), imageA8R8G8B8);

        <span class="comment">// gray-scale</span>
        <span class="keywordflow">for</span> ( <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> y = 0; y &lt; height; ++ y )
        {
            <span class="keywordflow">for</span> ( <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> x = 0; x &lt; pitch; ++x )
            {
                imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1video_1_1_i_image.html#a89bf6020ce6ac1066e4d585ce46f79bd" title="Sets a pixel.">setPixel</a> (x, y, <a class="code" href="classirr_1_1video_1_1_s_color.html" title="Class representing a 32 bit ARGB color.">video::SColor</a>(y, x,x,x) );
            }
        }
        driver-&gt;<a class="code" href="classirr_1_1video_1_1_i_video_driver.html#a8c02ee280bb738cdf38b77e7a798244e" title="Creates an empty texture of specified size.">addTexture</a> (<a class="code" href="classirr_1_1core_1_1string.html">io::path</a>(<span class="stringliteral">&quot;GRAYSCALE_A8R8G8B8&quot;</span>), imageA8R8G8B8);

        imageA8R8G8B8-&gt;<a class="code" href="classirr_1_1_i_reference_counted.html#afb169a857e0d2cdb96b8821cb9bff17a" title="Drops the object. Decrements the reference counter by one.">drop</a>();
    }

    <span class="comment">// Load a texture and make sure nodes know it when more textures are available.</span>
    <span class="keywordtype">void</span> loadTexture(<span class="keyword">const</span> <a class="code" href="classirr_1_1core_1_1string.html">io::path</a> &amp;name)
    {
        Device-&gt;getVideoDriver()-&gt;getTexture(name);
        NodeLeft.updateTextures();
        NodeRight.updateTextures();
    }

<span class="keyword">private</span>:
    SConfig                     Config;
    <span class="keyword">volatile</span> <span class="keywordtype">bool</span>               IsRunning;
    <a class="code" href="classirr_1_1_irrlicht_device.html" title="The Irrlicht device. You can create it with createDevice() or createDeviceEx().">IrrlichtDevice</a> *            Device;
    <a class="code" href="classirr_1_1scene_1_1_i_camera_scene_node.html" title="Scene Node which is a (controlable) camera.">scene::ICameraSceneNode</a> *   Camera;
    SMeshNodeControl            NodeLeft;
    SMeshNodeControl            NodeRight;
    SLightNodeControl           LightControl;
    CColorControl *             GlobalAmbient;
};
</pre></div><p>A very short main as we do everything else in classes. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    CApp APP;

    <span class="keywordflow">if</span> ( !APP.init(argc, argv) )
    {
        printf(<span class="stringliteral">&quot;init failed\n&quot;</span>);
        <span class="keywordflow">return</span> 1;
    }

    APP.run();
    APP.quit();

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">
<a href="http://irrlicht.sourceforge.net" target="_blank">Irrlicht 
Engine</a> Documentation &copy; 2003-2012 by Nikolaus Gebhardt. Generated on Tue Nov 6 2012 11:06:01 for Irrlicht 3D Engine by
<a href="http://www.doxygen.org/index.html" target="_blank">Doxygen</a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
